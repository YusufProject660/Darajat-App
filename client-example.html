<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trivia Rush - Game Client</title>
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      max-width: 800px; 
      margin: 0 auto; 
      padding: 20px; 
      line-height: 1.6; 
    }
    #messages { 
      height: 200px; 
      border: 1px solid #ccc; 
      padding: 10px; 
      margin-bottom: 20px; 
      overflow-y: auto; 
      background: #f9f9f9; 
    }
    .message { 
      margin: 5px 0; 
      padding: 5px; 
      border-bottom: 1px solid #eee; 
    }
    .system { color: #666; font-style: italic; }
    .received { color: #2c7be5; }
    .sent { color: #00a854; text-align: right; }
    .error { color: #e63757; }
    .controls { 
      display: flex; 
      gap: 10px; 
      margin-bottom: 20px; 
      flex-wrap: wrap;
    }
    input, button, select { 
      padding: 8px 12px; 
      font-size: 14px; 
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    button { 
      background: #2c7be5; 
      color: white; 
      border: none; 
      border-radius: 4px; 
      cursor: pointer; 
      min-width: 100px;
    }
    button:hover { background: #1a68d1; }
    button:disabled { 
      background: #ccc; 
      cursor: not-allowed; 
    }
    #gameArea { 
      display: none; 
      margin-top: 20px; 
      padding: 20px; 
      border: 1px solid #ddd; 
      border-radius: 5px; 
      background: #fff;
    }
    #options {
      display: grid;
      gap: 10px;
      margin: 20px 0;
    }
    #options button {
      text-align: left;
      padding: 12px;
      background: #f5f5f5;
      color: #333;
      border: 1px solid #ddd;
    }
    #options button:hover {
      background: #e9e9e9;
    }
    #options button.correct {
      background: #4CAF50;
      color: white;
    }
    #options button.incorrect {
      background: #f44336;
      color: white;
    }
    #timer {
      height: 5px;
      background: #2c7be5;
      width: 100%;
      transition: width 1s linear;
      margin-top: 10px;
    }
    #leaderboard {
      margin-top: 20px;
      padding: 15px;
      background: #f9f9f9;
      border-radius: 5px;
      display: none;
    }
    .player-score {
      display: flex;
      justify-content: space-between;
      padding: 8px;
      border-bottom: 1px solid #eee;
    }
    .player-score:last-child {
      border-bottom: none;
    }
  </style>
</head>
<body>
  <h1>Trivia Rush</h1>
  
  <div class="controls" style="display: flex; gap: 10px; margin-bottom: 20px;">
    <input type="text" id="serverUrl" value="http://localhost:5000" style="flex: 3; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
    <button id="connectBtn" style="padding: 8px 15px; background-color: #2c7be5; color: white; border: none; border-radius: 4px; cursor: pointer;">Connect</button>
    <button id="disconnectBtn" disabled style="padding: 8px 15px; background-color: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">Disconnect</button>
  </div>
  
  <div id="roomControls" style="display: none; margin: 20px 0; padding: 20px; border: 1px solid #eee; border-radius: 8px; background-color: #f9f9f9;">
    <h2 style="margin-top: 0; color: #333;">Join or Create a Game</h2>
    
    <div style="margin-bottom: 20px;">
      <h3>Create New Room</h3>
      <div style="display: flex; gap: 10px; margin-bottom: 15px;">
        <input type="text" id="playerName" placeholder="Your Name" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
        <button id="createRoomBtn" disabled style="padding: 8px 15px; background-color: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;">Create Room</button>
      </div>
    </div>
    
    <div style="text-align: center; margin: 20px 0; position: relative;">
      <hr style="border: 0; border-top: 1px solid #ddd;">
      <span style="background: #f9f9f9; padding: 0 10px; position: relative; top: -12px; color: #666;">OR</span>
    </div>
    
    <div style="margin-bottom: 15px;">
      <h3 onclick="join_room">Join Existing Room</h3>
      <div style="display: flex; gap: 10px;">
        <input type="text" id="roomId" placeholder="Enter Room Code" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px; text-transform: uppercase;">
        <button id="joinRoomBtn" disabled style="padding: 8px 15px; background-color: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;">Join Room</button>
        <button id="leaveRoomBtn" disabled style="padding: 8px 15px; background-color: #ffc107; color: #212529; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;">Leave Room</button>
      </div>
    </div>
    
    <div id="roomCodeDisplay" style="margin-top: 20px; padding: 15px; background: #e9ecef; border-radius: 6px; display: none; text-align: center;">
      <div style="font-size: 1.1em; margin-bottom: 10px; font-weight: bold;">Your Room Code:</div>
      <div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
        <span id="roomCode" style="font-size: 1.5em; font-weight: bold; letter-spacing: 2px; background: white; padding: 5px 15px; border-radius: 4px; border: 1px solid #ddd;"></span>
        <button id="copyRoomCode" style="padding: 5px 10px; background-color: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 5px;">
          <span>Copy</span>
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
        </button>
      </div>
      <div style="margin-top: 10px; font-size: 0.9em; color: #6c757d;">Share this code with other players</div>
    </div>
  </div>
  
  <div id="gameControls" style="display: none; margin-bottom: 20px;">
    <div id="gameStatus" style="margin-bottom: 10px; font-weight: bold;">Waiting for players...</div>
    
    <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-bottom: 10px;">
      <div style="display:flex; flex-direction:column; gap:6px;">
        <label for="categorySelect" style="font-size: 12px; color: #555;">Select Category</label>
        <select id="categorySelect" multiple size="6" style="min-width: 200px;">
          <!-- dynamically populated from /api/decks -->
        </select>
      </div>
      <select id="difficultySelect" style="padding: 8px;">
        <option value="all" selected>All Difficulties</option>
        <option value="easy">Easy</option>
        <option value="medium">Medium</option>
        <option value="hard">Hard</option>
      </select>
      <input type="number" id="questionCountInput" min="1" max="50" value="10" style="width: 100px;" />
      <div style="display:flex; align-items:center; gap:6px;">
        <span style="color:#555;">Players joined:</span>
        <span id="playerCount" style="font-weight:bold;">0</span>
      </div>
    </div>
    
    <button id="startGameBtn"  onclick={startGame}>Start Game</button>
  </div>
  
  <div id="gameArea">
    <h3>Question <span id="questionNumber">1</span> of <span id="totalQuestions">0</span></h3>
    <div id="questionText" style="font-size: 1.2em; margin: 15px 0; min-height: 60px;"></div>
    <div id="options" class="options"></div>
    <div class="progress" style="width: 100%; background-color: #e0e0e0; border-radius: 4px; margin: 10px 0;">
      <div id="timer" style="height: 20px; width: 100%; background-color: #2c7be5; border-radius: 4px; transition: width 1s linear;"></div>
    </div>
    <div>Time left: <span id="timeLeft">30</span>s</div>
    <div>Score: <span id="score">0</span> points</div>
  </div>
  
  <div id="leaderboard" style="display: none; margin-top: 20px; border: 1px solid #ddd; padding: 10px; border-radius: 4px;">
    <h3>Leaderboard</h3>
    <div id="leaderboardList"></div>
  </div>
  
  <div class="chat-container" style="margin-top: 20px; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
    <h3>Chat</h3>
    <div id="chatMessages" class="messages" style="height: 200px; overflow-y: auto; margin-bottom: 10px; border: 1px solid #eee; padding: 10px;"></div>
    <div class="message-input" style="display: flex;">
      <input type="text" id="messageInput" placeholder="Type a message..." disabled style="flex: 1; padding: 8px; margin-right: 5px; border: 1px solid #ddd; border-radius: 4px;">
      <button id="sendBtn" disabled style="padding: 8px 15px; background-color: #2c7be5; color: white; border: none; border-radius: 4px; cursor: pointer;">Send</button>
    </div>
  </div>
  
   <script>
    // Game state
    let socket = null;
    let currentRoom = null;
    let currentQuestion = null;
    let currentQuestionIndex = 0;
    let isHost = false;
    let timeLeft = 30;
    let timerInterval = null;
    let playerId = 'user-' + Math.random().toString(36).substr(2, 9);
    let playerName = '';
    
    // DOM Elements
    const elements = {
      serverUrl: document.getElementById('serverUrl'),
      connectBtn: document.getElementById('connectBtn'),
      disconnectBtn: document.getElementById('disconnectBtn'),
      playerName: document.getElementById('playerName'),
      roomId: document.getElementById('roomId'),
      joinRoomBtn: document.getElementById('joinRoomBtn'),
      createRoomBtn: document.getElementById('createRoomBtn'),
      leaveRoomBtn: document.getElementById('leaveRoomBtn'),
      startGameBtn: document.getElementById('startGameBtn'),
      gameStatus: document.getElementById('gameStatus'),
      gameControls: document.getElementById('gameControls'),
      gameArea: document.getElementById('gameArea'),
      questionText: document.getElementById('questionText'),
      options: document.getElementById('options'),
      messageInput: document.getElementById('messageInput'),
      sendBtn: document.getElementById('sendBtn'),
      chatMessages: document.getElementById('chatMessages') || document.getElementById('messages'), // Handle both possible IDs
      leaderboard: document.getElementById('leaderboard'),
      leaderboardList: document.getElementById('leaderboardList'),
      timer: document.getElementById('timer'),
      timeLeft: document.getElementById('timeLeft'),
      score: document.getElementById('score'),
      questionNumber: document.getElementById('questionNumber'),
      totalQuestions: document.getElementById('totalQuestions'),
      roomControls: document.getElementById('roomControls'),
      roomCodeDisplay: document.getElementById('roomCodeDisplay'),
      roomCode: document.getElementById('roomCode'),
      copyRoomCodeBtn: document.getElementById('copyRoomCode'),
      categorySelect: document.getElementById('categorySelect'),
      difficultySelect: document.getElementById('difficultySelect'),
      questionCountInput: document.getElementById('questionCountInput')
    };

    // Cache decks fetched from backend
    let availableDecks = [];
    let currentPlayerCount = 0;

    // Helper function to safely get DOM elements
    function getElement(id) {
      const el = document.getElementById(id);
      if (!el) console.warn(`Element with ID '${id}' not found`);
      return el;
    }

    // Initialize all elements
    function initializeElements() {
      // Add any additional initialization logic here
      if (elements.chatMessages) {
        elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
      }
    }

    // Initialize elements when DOM is loaded
    document.addEventListener('DOMContentLoaded', initializeElements);

    // Enable/disable buttons based on input
    function updateButtonStates() {
      const nameEntered = elements.playerName?.value.trim().length > 0;
      const roomIdEntered = elements.roomId?.value.trim().length > 0;
      const categorySelected = !!elements.categorySelect && elements.categorySelect.selectedOptions.length > 0;
      
      if (elements.createRoomBtn) {
        elements.createRoomBtn.disabled = !(socket?.connected && nameEntered);
      }
      if (elements.joinRoomBtn) {
        elements.joinRoomBtn.disabled = !(socket?.connected && nameEntered && roomIdEntered);
      }
      if (elements.startGameBtn) {
        elements.startGameBtn.disabled = !(socket?.connected && isHost && categorySelected);
      }
    }

    elements.playerName?.addEventListener('input', updateButtonStates);
    elements.roomId?.addEventListener('input', updateButtonStates);
    
    // Copy room code to clipboard
    elements.copyRoomCodeBtn?.addEventListener('click', () => {
      const roomCode = elements.roomCode?.textContent;
      if (!roomCode) return;
      
      navigator.clipboard.writeText(roomCode).then(() => {
        const originalText = elements.copyRoomCodeBtn.innerHTML;
        elements.copyRoomCodeBtn.innerHTML = '<span>Copied!</span>';
        setTimeout(() => {
          elements.copyRoomCodeBtn.innerHTML = originalText;
        }, 2000);
      }).catch(err => {
        console.error('Failed to copy room code:', err);
      });
    });

    // Helper Functions
    function addMessage(text, type = 'system') {
      if (!elements.chatMessages) {
        console.error('Chat messages container not found');
        return;
      }
      
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${type}`;
      messageDiv.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
      elements.chatMessages.appendChild(messageDiv);
      elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
    }

    function resetConnection() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }

      // Reset game state
      currentRoom = null;
      currentQuestion = null;
      currentQuestionIndex = 0;
      isHost = false;
      timeLeft = 30;

      // Reset UI
      const safeSetText = (element, text) => element && (element.textContent = text);
      const safeHide = (element) => element && (element.style.display = 'none');
      
      safeSetText(elements.timeLeft, '30');
      safeSetText(elements.score, '0');
      safeSetText(elements.questionText, '');
      
      if (elements.options) elements.options.innerHTML = '';
      
      // Hide UI sections
      safeHide(elements.gameControls);
      safeHide(elements.gameArea);
      if (elements.leaderboard) elements.leaderboard.style.display = 'none';
      
      // Reset button states
      if (elements.connectBtn) {
        elements.connectBtn.disabled = false;
        elements.connectBtn.textContent = 'Connect';
      }
      if (elements.disconnectBtn) elements.disconnectBtn.disabled = true;
      if (elements.joinRoomBtn) elements.joinRoomBtn.disabled = true;
      if (elements.createRoomBtn) elements.createRoomBtn.disabled = true;
      if (elements.leaveRoomBtn) elements.leaveRoomBtn.disabled = true;
      if (elements.startGameBtn) elements.startGameBtn.disabled = true;
      const pc = document.getElementById('playerCount');
      if (pc) pc.textContent = '0';
      currentPlayerCount = 0;
    }

    function startTimer() {
      if (!elements.timer || !elements.timeLeft) return;
      
      timeLeft = 30;
      elements.timer.style.width = '100%';
      elements.timer.style.background = '#2c7be5';
      elements.timeLeft.textContent = timeLeft;
      
      clearInterval(timerInterval);
      
      timerInterval = setInterval(() => {
        timeLeft--;
        const percentLeft = (timeLeft / 30) * 100;
        elements.timer.style.width = `${percentLeft}%`;
        elements.timeLeft.textContent = timeLeft;
        
        // Change color when time is running out
        if (timeLeft < 10) {
          elements.timer.style.background = '#e63757';
        } else if (timeLeft < 20) {
          elements.timer.style.background = '#ff9800';
        }
        
        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          submitAnswer('');
        }
      }, 1000);
    }

    function submitAnswer(answer) {
      if (!socket || !currentRoom || !currentQuestion) return;
      
      // Disable all answer buttons
      const buttons = elements.options?.getElementsByTagName('button') || [];
      for (let btn of buttons) {
        btn.disabled = true;
      }
      
      socket.emit('submit_answer', {
        roomCode: currentRoom,
        answer: answer,
        questionIndex: currentQuestionIndex
      });
    }

    async function fetchAndPopulateDecks() {
      const base = elements.serverUrl?.value.trim() || 'http://localhost:5000';
      try {
        // Load categories for the dropdown
        const catRes = await fetch(`${base}/api/categories`, { credentials: 'include' });
        const catJson = await catRes.json();
        if (!catJson.success) throw new Error(catJson.message || 'Failed to fetch categories');
        const categoryList = Array.isArray(catJson.categories) ? catJson.categories : [];

        if (elements.categorySelect) {
          elements.categorySelect.innerHTML = '';
          const allOpt = document.createElement('option');
          allOpt.value = 'all';
          allOpt.textContent = 'All Categories';
          elements.categorySelect.appendChild(allOpt);
          categoryList.forEach((c) => {
            const value = c._id || c.name || '';
            if (!value) return;
            const opt = document.createElement('option');
            opt.value = String(value);
            opt.textContent = (c.name || String(value)).toString();
            elements.categorySelect.appendChild(opt);
          });
        }

        // Also load decks for mapping to deckIds later
        const deckRes = await fetch(`${base}/api/decks?status=all`, { credentials: 'include' });
        const deckJson = await deckRes.json();
        availableDecks = deckJson?.decks || [];

        updateButtonStates();
      } catch (e) {
        console.error('Failed to load categories/decks:', e);
        addMessage(`Failed to load categories: ${e.message}`, 'error');
      }
    }

    elements.categorySelect?.addEventListener('change', updateButtonStates);
    elements.difficultySelect?.addEventListener('change', updateButtonStates);

    function deriveDeckIdsFromSelection() {
      const selectedCategories = Array.from(elements.categorySelect?.selectedOptions || []).map(o => o.value);
      const difficulty = elements.difficultySelect?.value || 'all';
      if (selectedCategories.includes('all')) {
        const filtered = availableDecks.filter(d => (difficulty === 'all' || d.difficulty === difficulty));
        return filtered.map(d => d._id);
      }
      const filtered = availableDecks.filter(d => selectedCategories.includes(d.category) && (difficulty === 'all' || d.difficulty === difficulty));
      return filtered.map(d => d._id);
    }

    function setPlayerCount(count) {
      currentPlayerCount = count || 0;
      const pc = document.getElementById('playerCount');
      if (pc) pc.textContent = String(currentPlayerCount);
      updateButtonStates();
    }

    function startGame() {
      console.log('socket:', socket);
      console.log('currentRoom:', currentRoom);
      if (!socket || !currentRoom) return;
      
      console.log('Starting game in room:', currentRoom);
      addMessage('Starting game...', 'system');
      
      console.log('Emitting start_game event with room:', currentRoom);
      // Emit start_game event to server with  roomCode
      socket.emit('start_game', { roomCode: currentRoom }, (response) => {
        console.log('start_game response:', response);
        if (response && response.success) {
          console.log('Game started successfully:', response);
          addMessage('Game started!', 'system');
          
          // Update UI
          if (elements.gameArea) elements.gameArea.style.display = 'block';
          if (elements.startGameBtn) elements.startGameBtn.disabled = true;
          if (elements.leaveRoomBtn) elements.leaveRoomBtn.disabled = true;
        } else {
          const error = response?.error || 'Failed to start game';
          console.error('Error starting game:', error);
          addMessage(`Error: ${error}`, 'error');
          
          // Re-enable start button on error
          if (elements.startGameBtn) elements.startGameBtn.disabled = false;
        }
      });
    }

    // Event Listeners
    elements.connectBtn?.addEventListener('click', connectToServer);
    elements.disconnectBtn?.addEventListener('click', disconnectFromServer);
    elements.createRoomBtn?.addEventListener('click', createRoom);
    elements.joinRoomBtn?.addEventListener('click', joinRoom);
    elements.leaveRoomBtn?.addEventListener('click', leaveRoom);
    elements.startGameBtn?.addEventListener('click', startGame);
    elements.sendBtn?.addEventListener('click', sendMessage);
    elements.messageInput?.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        sendMessage();
      }
    });

    function connectToServer() {
      const serverUrl = elements.serverUrl?.value.trim() || 'http://localhost:5000';
      
      console.log('Connect button clicked, server URL:', serverUrl);
      addMessage(`Connecting to ${serverUrl}...`, 'system');
      
      // Disable connect button to prevent multiple clicks
      elements.connectBtn.disabled = true;
      elements.connectBtn.textContent = 'Connecting...';
      
      // Disconnect if already connected
      if (socket) {
        console.log('Disconnecting existing socket connection');
        socket.disconnect();
      }
      
      console.log('Creating new socket connection');
      
      try {
        // Connect to the server with explicit path configuration
        socket = io(serverUrl, {
          reconnection: true,
          reconnectionAttempts: 5,
          reconnectionDelay: 1000,
          timeout: 20000,
          transports: ['websocket', 'polling'],
          withCredentials: true,
          path: '/ws/socket.io'  // Match server's WebSocket path
        });
        
        console.log('Socket created, setting up handlers');
        
        // Initialize socket event handlers
        setupSocketHandlers(socket);
        
        // Set a timeout for connection
        const connectionTimeout = setTimeout(() => {
          if (socket && !socket.connected) {
            console.error('Connection timeout');
            addMessage('Connection timeout. Please check the server URL and try again.', 'error');
            resetConnection();
            updateButtonStates();
          }
        }, 5000);

        // Clear timeout on successful connection
        socket.once('connect', () => {
          console.log('Connection successful, clearing timeout');
          clearTimeout(connectionTimeout);
          
          // Update UI for connected state
          elements.connectBtn.disabled = true;
          elements.connectBtn.textContent = 'Connected';
          elements.disconnectBtn.disabled = false;
          
          // Show room controls
          if (elements.roomControls) {
            elements.roomControls.style.display = 'block';
          }
          
          // Update button states
          updateButtonStates();
          
          addMessage('Successfully connected to server', 'system');
          // Fetch available decks for selectors
          fetchAndPopulateDecks();
        });
      } catch (error) {
        console.error('Connection failed:', error);
        addMessage(`Failed to connect: ${error.message}`, 'error');
        resetConnection();
        updateButtonStates();
      }
    }

    function disconnectFromServer() {
      if (socket) {
        socket.disconnect();
        resetConnection();
        addMessage('Disconnected from server', 'system');
      }
    }

  // Setup socket event handlers
  function setupSocketHandlers(socket) {
    // Connection event handlers
    socket.on('connect', () => {
      console.log('Socket connected:', socket.connected);
      addMessage('Connected to game server', 'system');
    });
    
    socket.on('connect_error', (error) => {
      console.error('Connection error:', error);
      addMessage(`Connection error: ${error.message || 'Unknown error'}`, 'error');
    });
      
    socket.on('disconnect', (reason) => {
      console.log('Disconnected:', reason);
      addMessage(`Disconnected: ${reason}`, 'system');
      if (reason === 'io server disconnect') {
        // The disconnection was initiated by the server, try to reconnect
        socket.connect();
      }
    });

    // Game event handlers
    socket.on('player_joined', (data) => {
      addMessage(`${data.player?.username || 'A player'} joined the room`, 'system');
      
      // Update player list if available
      if (data.room?.players) {
        updatePlayerList(data.room.players);
      }
      if (data.room?.players) {
        setPlayerCount(data.room.players.length);
      }
    });
      
    socket.on('player_left', (data) => {
      addMessage(`${data.playerId} left the room`, 'system');
      
      // Update player list if available
      if (data.players) {
        updatePlayerList(data.players);
      }
      if (data.players) {
        setPlayerCount(data.players.length);
      }
    });
    
    socket.on('host_changed', (data) => {
      addMessage(`New host: ${data.newHostName || data.newHostId}`, 'system');
    });
      
    socket.on('room_created', (data) => {
      if (data.success) {
        addMessage(`Room ${data.roomCode} created successfully`, 'success');
        
        // Update UI for host
        if (elements.roomCode) {
          elements.roomCode.textContent = data.roomCode;
        }
        
        // Enable/disable UI elements
        if (elements.roomId) {
          elements.roomId.disabled = true;
          elements.roomId.value = data.roomCode;
        }
        
        if (elements.joinRoomBtn) {
          elements.joinRoomBtn.disabled = true;
        }
        
        if (elements.leaveRoomBtn) {
          elements.leaveRoomBtn.disabled = false;
        }
        
        // Show game controls for host
        if (elements.gameControls) {
          elements.gameControls.style.display = 'block';
        }

        // Show room code (host only view after creation)
        if (elements.roomCodeDisplay) {
          elements.roomCodeDisplay.style.display = 'block';
        }
        
        // Update player list
        if (data.players) {
          updatePlayerList(data.players);
        }
      } else {
        addMessage(`Failed to create room: ${data.error || 'Unknown error'}`, 'error');
      }
    });
      
    socket.on('room_joined', (data) => {
      if (data.success) {
        addMessage(`Joined room ${data.roomCode}`, 'success');
        
        // Update UI for player
        if (elements.roomCode) {
          elements.roomCode.textContent = data.roomCode;
        }
        
        // Enable/disable UI elements
        if (elements.roomId) {
          elements.roomId.disabled = true;
        }
        
        if (elements.joinRoomBtn) {
          elements.joinRoomBtn.disabled = true;
        }
        
        if (elements.leaveRoomBtn) {
          elements.leaveRoomBtn.disabled = false;
        }
        
        // Show game controls for player
        if (elements.gameControls) {
          elements.gameControls.style.display = 'block';
        }
        
        // Update player list
        if (data.players) {
          updatePlayerList(data.players);
        }
        if (data.players) {
          setPlayerCount(data.players.length);
        }
        
        // Show room code only for host
        if (elements.roomCodeDisplay) {
          elements.roomCodeDisplay.style.display = data.isHost ? 'block' : 'none';
        }
        // Show start button only for host
        if (elements.startGameBtn) {
          elements.startGameBtn.style.display = data.isHost ? 'block' : 'none';
        }
      } else {
        addMessage(`Failed to join room: ${data.error || 'Unknown error'}`, 'error');
      }
    });
      
    socket.on('game_started', (data) => {
      if (elements.gameStatus) {
        elements.gameStatus.textContent = `Game started! ${data.totalQuestions} questions in total.`;
      }
      
      if (elements.startGameBtn) {
        elements.startGameBtn.disabled = true;
      }
      
      if (elements.gameArea) {
        elements.gameArea.style.display = 'block';
      }
      
      if (elements.leaderboard) {
        elements.leaderboard.style.display = 'block';
      }
    });
      
    socket.on('question', (data) => {
      if (elements.questionText) {
        elements.questionText.textContent = data.question;
      }
      
      // Update current question data
      currentQuestion = data;
      currentQuestionIndex = data.questionNumber - 1; // Convert to 0-based index
      
      // Update question number and total questions
      if (elements.questionNumber) {
        elements.questionNumber.textContent = data.questionNumber || '1';
      }
      if (elements.totalQuestions) {
        elements.totalQuestions.textContent = data.totalQuestions || '0';
      }
      
      if (elements.options) {
        // Clear previous options
        elements.options.innerHTML = '';
        
        // Add new options
        data.options.forEach((option, index) => {
          const button = document.createElement('button');
          button.textContent = option;
          button.onclick = () => submitAnswer(index);
          elements.options.appendChild(button);
        });
      }
      
      // Start the timer
      startTimer();
    });
      
    socket.on('answer_result', (data) => {
      if (data.isCorrect) {
        addMessage('Correct! +10 points', 'system');
      } else {
        addMessage(`Incorrect! The correct answer was: ${data.correctAnswer}`, 'system');
      }
      
      // Update score display
      if (elements.score) {
        elements.score.textContent = data.score || '0';
      }
      
      // Disable all option buttons and show correct/incorrect states
      const buttons = elements.options?.getElementsByTagName('button') || [];
      for (let btn of buttons) {
        btn.disabled = true;
        if (btn.textContent === data.correctAnswer) {
          btn.classList.add('correct');
        } else if (btn.textContent !== data.correctAnswer) {
          btn.classList.add('incorrect');
        }
      }
    });
      
    socket.on('game_ended', (data) => {
      clearInterval(timerInterval);
      
      if (elements.gameStatus) {
        elements.gameStatus.textContent = 'Game Over!';
      }
      
      if (elements.gameArea) {
        elements.gameArea.style.display = 'none';
      }
      
      // Show final leaderboard with positions
      if (elements.leaderboardList) {
        elements.leaderboardList.innerHTML = '';
        
        // Add game summary
        const summaryEl = document.createElement('div');
        summaryEl.style.cssText = 'text-align: center; margin-bottom: 15px; padding: 10px; background: #f0f0f0; border-radius: 5px;';
        summaryEl.innerHTML = `
          <h4 style="margin: 0 0 5px 0; color: #333;">🎯 Game Complete!</h4>
          <p style="margin: 0; color: #666; font-size: 14px;">${data.totalQuestions || data.players.length} questions answered</p>
        `;
        elements.leaderboardList.appendChild(summaryEl);
        
        // Add final rankings
        data.players.sort((a, b) => b.score - a.score).forEach((player, index) => {
          const playerEl = document.createElement('div');
          playerEl.className = 'player-score';
          
          // Add position styling
          let positionClass = '';
          let positionIcon = '';
          if (index === 0) {
            positionClass = 'background: #ffd700; border: 2px solid #ffed4e;';
            positionIcon = '🥇';
          } else if (index === 1) {
            positionClass = 'background: #c0c0c0; border: 2px solid #e5e5e5;';
            positionIcon = '🥈';
          } else if (index === 2) {
            positionClass = 'background: #cd7f32; border: 2px solid #daa520;';
            positionIcon = '🥉';
          } else {
            positionIcon = `#${index + 1}`;
          }
          
          playerEl.style.cssText = `
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            padding: 12px; 
            margin: 8px 0; 
            border-radius: 8px; 
            ${positionClass}
            font-weight: ${index < 3 ? 'bold' : 'normal'};
            font-size: ${index < 3 ? '16px' : '14px'};
          `;
          
          playerEl.innerHTML = `
            <span style="display: flex; align-items: center; gap: 8px;">
              <span style="font-size: 18px;">${positionIcon}</span>
              <span>${player.username} ${player.isHost ? '(Host)' : ''}</span>
            </span>
            <span style="font-weight: bold; color: #2c3e50;">${player.score} pts</span>
          `;
          elements.leaderboardList.appendChild(playerEl);
        });
      }
      
      if (elements.leaderboard) {
        elements.leaderboard.style.display = 'block';
        elements.leaderboard.style.cssText = `
          display: block !important; 
          margin-top: 20px; 
          border: 2px solid #3498db; 
          padding: 15px; 
          border-radius: 10px; 
          background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
          box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        `;
      }
      
      addMessage('🏆 Game Over! Check the leaderboard above for final results!', 'system');
    });

    // Handle real-time leaderboard updates during game
    socket.on('leaderboardUpdate', (data) => {
      if (elements.leaderboardList && elements.leaderboard) {
        elements.leaderboardList.innerHTML = '';
        
        // Add current game status
        const statusEl = document.createElement('div');
        statusEl.style.cssText = 'text-align: center; margin-bottom: 10px; padding: 8px; background: #e3f2fd; border-radius: 5px;';
        statusEl.innerHTML = `
          <h4 style="margin: 0; color: #1976d2; font-size: 16px;">📊 Current Rankings</h4>
        `;
        elements.leaderboardList.appendChild(statusEl);
        
        // Show current standings
        data.leaderboard.forEach((player, index) => {
          const playerEl = document.createElement('div');
          playerEl.className = 'player-score';
          playerEl.style.cssText = `
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            padding: 8px; 
            margin: 4px 0; 
            border-radius: 5px; 
            background: ${index < 3 ? '#f8f9fa' : '#ffffff'};
            border: 1px solid #dee2e6;
            font-size: 14px;
          `;
          
          const positionIcon = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}.`;
          
          playerEl.innerHTML = `
            <span style="display: flex; align-items: center; gap: 6px;">
              <span>${positionIcon}</span>
              <span>${player.username}</span>
            </span>
            <span style="font-weight: bold; color: #2c3e50;">${player.score} pts</span>
          `;
          elements.leaderboardList.appendChild(playerEl);
        });
      }
    });
      
    // Handle chat messages
    socket.on('chat_message', (data) => {
      addMessage(`${data.sender}: ${data.message}`, 'received');
    });
      
      // Add room_updated handler inside setupSocketHandlers
      socket.on('room_updated', (data) => {
        console.log('Room updated:', data);
        if (elements.leaderboardList) {
          elements.leaderboardList.innerHTML = '';
          data.players.forEach(player => {
            const playerEl = document.createElement('div');
            playerEl.className = 'player-score';
            playerEl.innerHTML = `
              <span>${player.username} ${player.isHost ? '(Host)' : ''}</span>
              <span>${player.score} pts</span>
            `;
            elements.leaderboardList.appendChild(playerEl);
          });
        }
        if (elements.leaderboard) {
          elements.leaderboard.style.display = data.players.length > 0 ? 'block' : 'none';
        }
        
        // Update game controls based on room state
        if (elements.startGameBtn) {
          elements.startGameBtn.disabled = !isHost || data.isStarted;
        }
        
        // Update game status
        if (elements.gameStatus) {
          if (data.isStarted) {
            elements.gameStatus.textContent = 'Game in progress';
          } else {
            const playerCount = data.players.length;
            elements.gameStatus.textContent = `Waiting for players (${playerCount} connected)`;
          }
        }
        setPlayerCount(data.players?.length || 0);
      });
    }
  
  // Helper function to update player list
  function updatePlayerList(players) {
    if (elements.playerList) {
      elements.playerList.innerHTML = '';
      players.forEach(player => {
        const playerEl = document.createElement('div');
        playerEl.className = 'player' + (player.isHost ? ' host' : '');
        playerEl.textContent = `${player.username}${player.isHost ? ' (Host)' : ''} - ${player.score} pts`;
        elements.playerList.appendChild(playerEl);
      });
    }
  }


// Add this new handler when first joining a room
function joinRoom() {
  const roomId = elements.roomId?.value.trim().toUpperCase() || '';
  const name = elements.playerName?.value.trim() || '';
  
  if (!roomId || !name) {
    addMessage('Please enter both room code and your name', 'error');
    return;
  }
  
  if (!socket || !socket.connected) {
    addMessage('Not connected to server', 'error');
    return;
  }
  
  playerName = name; // Store the player name in the global variable
  const joinBtn = elements.joinRoomBtn;
  if (joinBtn) {
    joinBtn.disabled = true;
    joinBtn.textContent = 'Joining...';
  }
  
  console.log(`Joining room: ${roomId} as ${name}`);
  addMessage(`Attempting to join room: ${roomId}...`, 'system');

  // Emit the join_room event
  socket.emit('join_room', {
    roomCode: roomId,
    playerName: name
  }, (response) => {
    console.log('Join room response:', response);
    
    if (response && response.success) {
      currentRoom = roomId;
      isHost = response.isHost || false;
      
      // Update UI
      if (elements.roomCodeDisplay) {
        elements.roomCodeDisplay.style.display = 'block';
      }
      if (elements.roomCode) {
        elements.roomCode.textContent = roomId;
      }
      if (elements.gameControls) {
        elements.gameControls.style.display = 'block';
      }
      if (elements.startGameBtn) {
        elements.startGameBtn.disabled = !isHost;
      }
      if (elements.gameStatus) {
        elements.gameStatus.textContent = isHost 
          ? 'You are the host. Start the game when ready.' 
          : 'Waiting for host to start the game...';
      }
      
      // Update button states
      if (elements.joinRoomBtn) elements.joinRoomBtn.disabled = true;
      if (elements.createRoomBtn) elements.createRoomBtn.disabled = true;
      if (elements.leaveRoomBtn) elements.leaveRoomBtn.disabled = false;
      if (elements.messageInput) elements.messageInput.disabled = false;
      if (elements.sendBtn) elements.sendBtn.disabled = false;
      
      addMessage(`Successfully joined room: ${roomId}`, 'success');
      addMessage(`You are ${isHost ? 'the host' : 'a player'}`, 'system');
    } else {
      const errorMsg = response?.error || 'Failed to join room. The room may not exist or the game has already started.';
      console.error('Failed to join room:', errorMsg);
      addMessage(`Error: ${errorMsg}`, 'error');
      
      // Reset join button state on error
      if (joinBtn) {
        joinBtn.disabled = false;
        joinBtn.textContent = 'Join Room';
      }
    }
  });
}


  function createRoom() {
      const name = elements.playerName?.value.trim() || '';
      
      if (!name) {
        addMessage('Please enter your name', 'error');
        return;
      }
      
      if (!socket || !socket.connected) {
        addMessage('Not connected to server', 'error');
        return;
      }
      
      playerName = name;
      const createBtn = elements.createRoomBtn;
      createBtn.disabled = true;
      createBtn.textContent = 'Creating...';
      
      // Generate a random 4-letter room code
      const roomCode = Math.random().toString(36).substring(2, 6).toUpperCase();
      
      // Set a timeout for the room creation
      console.log('Attempting to create room with code:', roomCode);
      
      socket.emit('create_room', {
        roomCode: roomCode,
        playerName: name
      }, (response) => {
        
        if (response && response.success) {
          console.log('Room created successfully:', roomCode);
          currentRoom = roomCode;
          isHost = true;
          
          // Update UI for host
          if (elements.roomId) {
            elements.roomId.value = roomCode;
          }
          if (elements.roomCodeDisplay) {
            elements.roomCodeDisplay.style.display = 'block';
          }
          if (elements.roomCode) {
            elements.roomCode.textContent = roomCode;
          }
          
          if (elements.gameControls) {
            elements.gameControls.style.display = 'block';
          }
          if (elements.startGameBtn) {
            elements.startGameBtn.disabled = false;
          }
          if (elements.gameStatus) {
            elements.gameStatus.textContent = 'You are the host. Share the room code with others.';
          }
          
          if (elements.joinRoomBtn) elements.joinRoomBtn.disabled = true;
          if (elements.leaveRoomBtn) elements.leaveRoomBtn.disabled = false;
          if (elements.messageInput) elements.messageInput.disabled = false;
          if (elements.sendBtn) elements.sendBtn.disabled = false;
          
          addMessage(`Created room: ${roomCode}`, 'system');
          addMessage('Share this code with other players to join', 'system');
        } else {
          const errorMsg = response?.error || 'Failed to create room. The server may be unavailable.';
          console.error('Room creation failed:', errorMsg);
          addMessage(errorMsg, 'error');
          createBtn.disabled = false;
          createBtn.textContent = 'Create Room';
        }
      });
    }


    function leaveRoom() {
      if (socket && currentRoom) {
        socket.emit('leave_room', { roomCode: currentRoom });
        addMessage(`Left room: ${currentRoom}`, 'system');
        currentRoom = null;
        isHost = false;
        
        if (elements.gameControls) elements.gameControls.style.display = 'none';
        if (elements.gameArea) elements.gameArea.style.display = 'none';
        if (elements.leaderboard) elements.leaderboard.style.display = 'none';
        if (elements.joinRoomBtn) elements.joinRoomBtn.disabled = false;
        if (elements.leaveRoomBtn) elements.leaveRoomBtn.disabled = true;
        if (elements.joinRoomBtn) elements.joinRoomBtn.textContent = 'Join Room';
        if (elements.roomCodeDisplay) elements.roomCodeDisplay.style.display = 'none';
      }
    }

    function startGame() {
      console.log('startGame() called');
      console.log('Socket connected:', socket?.connected);
      console.log('Current room:', currentRoom);
      
      if (!socket) {
        console.error('No socket connection');
        return;
      }
      
      if (!currentRoom) {
        console.error('No room selected');
        return;
      }
      
      console.log('Starting game in room:', currentRoom);
      addMessage('Starting game...', 'system');
      
      if (elements.startGameBtn) {
        elements.startGameBtn.disabled = true;
      }
      if (elements.gameStatus) {
        elements.gameStatus.textContent = 'Starting game...';
      }
      
      const deckIds = deriveDeckIdsFromSelection();
      const selectedCategories = Array.from(elements.categorySelect?.selectedOptions || []).map(o => o.value);
      const category = selectedCategories.length === 1 ? selectedCategories[0] : undefined;
      const difficulty = elements.difficultySelect?.value || 'all';
      const questionCount = parseInt(elements.questionCountInput?.value || '10', 10);

      const gameConfig = {
        roomCode: currentRoom,
        deckIds,
        category,
        difficulty,
        questionCount
      };
      
      console.log('Emitting start_game event with config:', gameConfig);
      
      socket.emit('start_game', gameConfig, (response) => {
        console.log('Received response from start_game:', response);
        
        if (!response) {
          console.error('No response received from server');
          if (elements.gameStatus) {
            elements.gameStatus.textContent = 'No response from server';
          }
        } else if (!response.success) {
          console.error('Failed to start game:', response.error);
          if (elements.gameStatus) {
            elements.gameStatus.textContent = 'Error: ' + (response.error || 'Unknown error');
          }
          if (response.details) {
            addMessage('Details: ' + JSON.stringify(response.details), 'error');
          }
        } else {
          console.log('Game started successfully');
          if (elements.gameStatus) {
            elements.gameStatus.textContent = 'Game started!';
          }
        }
        
        if (elements.startGameBtn) {
          elements.startGameBtn.disabled = !!response?.success;
        }
      });
    }

    function sendMessage() {
      const message = elements.messageInput?.value.trim();
      if (!message || !socket || !currentRoom) return;
      
      socket.emit('chat_message', {
        roomCode: currentRoom,
        message: message,
        sender: playerName || 'Anonymous'
      });
      
      addMessage(`You: ${message}`, 'sent');
      elements.messageInput.value = '';
    }
    
    // Initialize
    resetConnection();
  </script>
</body>
</html>