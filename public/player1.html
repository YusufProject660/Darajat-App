<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Player 1 - Host (Game Test)</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .content { padding: 30px; display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            border-left: 5px solid #4caf50;
        }
        .section h2 { color: #4caf50; margin-bottom: 20px; font-size: 1.5em; }
        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 8px; color: #333; font-weight: 600; }
        input, select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #4caf50;
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
        }
        button {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            margin-top: 10px;
        }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4); }
        button:disabled { opacity: 0.6; cursor: not-allowed; }
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-weight: 500;
        }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .log-container {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-top: 20px;
        }
        .log-entry { margin-bottom: 8px; padding: 5px; border-left: 3px solid transparent; }
        .log-entry.success { border-left-color: #4caf50; color: #4caf50; }
        .log-entry.error { border-left-color: #f44336; color: #f44336; }
        .log-entry.info { border-left-color: #2196f3; color: #2196f3; }
        .hidden { display: none; }
        .question-container {
            background: #fff3e0;
            padding: 25px;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #ff9800;
        }
        .question-container h3 { 
            color: #e65100; 
            margin-bottom: 15px; 
            font-size: 1.3em;
        }
        .question-text {
            font-size: 1.3em;
            font-weight: 500;
            color: #333;
            margin: 20px 0;
            line-height: 1.6;
        }
        .option-btn {
            display: block;
            width: 100%;
            padding: 18px 20px;
            margin: 12px 0;
            background: white;
            border: 3px solid #e0e0e0;
            border-radius: 10px;
            cursor: pointer;
            text-align: left;
            transition: all 0.3s;
            font-size: 1.1em;
            font-weight: 500;
        }
        .option-btn:hover { 
            border-color: #4caf50; 
            background: #f1f8f4; 
            transform: translateX(5px);
            box-shadow: 0 4px 8px rgba(76, 175, 80, 0.2);
        }
        .option-btn:active {
            transform: translateX(2px);
        }
        .option-btn:disabled { 
            opacity: 0.5; 
            cursor: not-allowed; 
            transform: none;
        }
        .timer {
            font-size: 3em;
            font-weight: bold;
            color: #4caf50;
            text-align: center;
            padding: 20px;
            background: #f1f8f4;
            border-radius: 10px;
            margin: 15px 0;
            border: 3px solid #4caf50;
        }
        .timer.warning {
            color: #ff9800;
            border-color: #ff9800;
            background: #fff3e0;
        }
        .timer.danger {
            color: #f44336;
            border-color: #f44336;
            background: #ffebee;
        }
        .players-list {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
        }
        .player-item {
            padding: 10px;
            margin: 5px 0;
            background: #f8f9fa;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
        }
        .badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }
        .badge.host { background: #4caf50; color: white; }
        .badge.ready { background: #2196f3; color: white; }
        .full-width { grid-column: 1 / -1; }
        .api-response-container {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            max-height: 500px;
            overflow-y: auto;
        }
        .api-response-container h3 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 16px;
        }
        .api-response-content {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .api-response-content.empty {
            color: #6c757d;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üëë Player 1 - HOST</h1>
            <p>Complete Game Flow Testing - Create Room, Start Game, Answer Questions</p>
        </div>
        <div class="content">
            <!-- Login Section -->
            <div class="section">
                <h2>üîê Step 1: Login</h2>
                <div class="form-group">
                    <label for="serverUrl">Server URL:</label>
                    <input type="text" id="serverUrl" value="http://localhost:5000" placeholder="http://localhost:5000">
                    <button onclick="testConnection()" style="margin-top: 5px; padding: 8px 15px; font-size: 14px; width: auto;">Test Connection</button>
                </div>
                <div class="form-group">
                    <label>Email:</label>
                    <input type="email" id="email" value="player1@test.com" placeholder="Enter email">
                </div>
                <div class="form-group">
                    <label>Password:</label>
                    <input type="password" id="password" value="password123" placeholder="Enter password">
                </div>
                <button onclick="login()">Login</button>
                <div id="loginStatus"></div>
            </div>

            <!-- Socket Status -->
            <div class="section">
                <h2>üîå Socket Status</h2>
                <div id="socketStatus" class="status info">Not Connected</div>
                <button onclick="connectSocket()" id="connectBtn" disabled>Connect Socket</button>
            </div>

            <!-- Room Management Section -->
            <div class="section hidden full-width" id="roomSection">
                <h2>üè† Room Management</h2>
                
                <!-- Create Room -->
                <div style="background: #e8f5e9; padding: 20px; border-radius: 10px; margin-bottom: 20px; border-left: 5px solid #4caf50;">
                    <h3 style="color: #2e7d32; margin-bottom: 15px;">Create Room (Host)</h3>
                <div class="form-group">
                    <label>Room Code:</label>
                    <input type="text" id="roomCode" placeholder="Auto-generated" readonly>
                </div>
                <div class="form-group">
                    <label>Game ID:</label>
                    <input type="text" id="gameId" value="trivia_rush" placeholder="trivia_rush">
                </div>
                <div class="form-group">
                    <label>Number of Questions:</label>
                    <input type="number" id="numberOfQuestions" value="5" min="1" max="10">
                </div>
                <div class="form-group">
                    <label>Max Players:</label>
                    <input type="number" id="maximumPlayers" value="7" min="2" max="10">
                </div>
                <div class="form-group">
                    <label>Categories:</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                        <div>
                            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                                <input type="checkbox" id="catQuran" checked>
                                <span>Quran</span>
                            </label>
                            <select id="diffQuran" style="width: 100%; padding: 8px; border-radius: 5px;">
                                <option value="easy">Easy</option>
                                <option value="medium" selected>Medium</option>
                                <option value="hard">Hard</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                                <input type="checkbox" id="catHadith">
                                <span>Hadith</span>
                            </label>
                            <select id="diffHadith" style="width: 100%; padding: 8px; border-radius: 5px;">
                                <option value="easy">Easy</option>
                                <option value="medium" selected>Medium</option>
                                <option value="hard">Hard</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                                <input type="checkbox" id="catHistory">
                                <span>History</span>
                            </label>
                            <select id="diffHistory" style="width: 100%; padding: 8px; border-radius: 5px;">
                                <option value="easy">Easy</option>
                                <option value="medium" selected>Medium</option>
                                <option value="hard">Hard</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                                <input type="checkbox" id="catFiqh">
                                <span>Fiqh</span>
                            </label>
                            <select id="diffFiqh" style="width: 100%; padding: 8px; border-radius: 5px;">
                                <option value="easy">Easy</option>
                                <option value="medium" selected>Medium</option>
                                <option value="hard">Hard</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                                <input type="checkbox" id="catSeerah">
                                <span>Seerah</span>
                            </label>
                            <select id="diffSeerah" style="width: 100%; padding: 8px; border-radius: 5px;">
                                <option value="easy">Easy</option>
                                <option value="medium" selected>Medium</option>
                                <option value="hard">Hard</option>
                            </select>
                        </div>
                    </div>
                </div>
                    <button onclick="createRoom()" style="background: #4caf50;">Create Room</button>
                    <div id="createRoomStatus"></div>
                </div>

                <!-- Join Room -->
                <div style="background: #e3f2fd; padding: 20px; border-radius: 10px; border-left: 5px solid #2196f3;">
                    <h3 style="color: #1565c0; margin-bottom: 15px;">Join Room (Player)</h3>
                    <div class="form-group">
                        <label>Room Code:</label>
                        <input type="text" id="joinRoomCode" placeholder="Enter room code (e.g., ROOM1234567890)" style="text-transform: uppercase;">
                    </div>
                    <button onclick="joinRoom()" style="background: #2196f3;">Join Room</button>
                    <div id="joinRoomStatus"></div>
                    <p style="margin-top: 10px; font-size: 0.9em; color: #666;">
                        üí° Tip: Get room code from host who created the room
                    </p>
                </div>
            </div>

            <!-- Lobby Section -->
            <div class="section hidden" id="lobbySection">
                <h2>üë• Lobby</h2>
                <div id="roomInfo"></div>
                <div id="playersList" class="players-list"></div>
                <button onclick="startGame()" id="startBtn" style="background: #f44336; margin-top: 10px;" disabled>Start Game (Host Only)</button>
                <button onclick="leaveRoom()" id="leaveBtn" style="background: #ff9800; margin-top: 10px;">Leave Room</button>
                <div id="lobbyStatus"></div>
            </div>

            <!-- Game Section -->
            <div class="section hidden full-width" id="gameSection">
                <h2>üéÆ Game In Progress</h2>
                <div style="text-align: center; margin-bottom: 20px;">
                    <div class="timer" id="timer">--</div>
                    <p style="color: #666; margin-top: 10px;">Time Remaining</p>
                </div>
                <div id="questionContainer" class="question-container"></div>
                <div id="gameStatus"></div>
                <div style="margin-top: 20px; padding: 15px; background: #e3f2fd; border-radius: 8px;">
                    <p style="margin: 0; color: #1976d2;">
                        <strong>üí° Instructions:</strong> Click on an option to answer, or wait for timer to expire (will auto-skip)
                    </p>
                </div>
            </div>

            <!-- Summary Section -->
            <div class="section hidden full-width" id="summarySection">
                <h2>üìä Game Summary</h2>
                <div id="summaryContent"></div>
                <button onclick="getLeaderboard()">View Leaderboard</button>
                <div id="leaderboardContent"></div>
            </div>

            <!-- API Testing Section -->
            <div class="section full-width">
                <h2>üß™ API Testing</h2>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                    <button onclick="testGetLobby()" style="background: #2196f3;">Get Lobby</button>
                    <button onclick="testGetQuestions()" style="background: #2196f3;">Get Questions</button>
                    <button onclick="testGetSummary()" style="background: #2196f3;">Get Summary</button>
                    <button onclick="testGetLeaderboard()" style="background: #2196f3;">Get Leaderboard</button>
                    <button onclick="testGetMyGames()" style="background: #2196f3;">Get My Games</button>
                    <button onclick="testGetRoom()" style="background: #2196f3;">Get Room</button>
                </div>
                <div id="apiResponse" class="log-container" style="max-height: 200px; margin-top: 15px;"></div>
            </div>

            <!-- API Response Section -->
            <div class="section full-width">
                <h2>üì° API Response</h2>
                <button onclick="clearApiResponse()" style="background: #6c757d; margin-bottom: 15px;">Clear Response</button>
                <div class="api-response-container">
                    <h3>Last API Response:</h3>
                    <div id="apiResponseDisplay" class="api-response-content empty">No API response yet...</div>
                </div>
            </div>

            <!-- Logs Section -->
            <div class="section full-width">
                <h2>üìù Event Logs</h2>
                <button onclick="clearLogs()" style="background: #f44336; margin-bottom: 15px;">Clear Logs</button>
                <div class="log-container" id="logs"></div>
            </div>
        </div>
    </div>

    <script>
        let API_URL = 'http://localhost:5000';
        let SOCKET_URL = 'http://localhost:5000';
        
        let token = '';
        let socket = null;
        let currentUser = null;
        let currentRoom = null;
        let currentQuestion = null;
        let currentQuestionIndex = 0;
        let totalQuestions = 0;
        let allQuestions = []; // Store all questions
        let timerInterval = null;
        let timeLeft = 0;
        let timeLimit = 30; // Store timeLimit globally
        let isHost = false;
        let hasAnsweredCurrentQuestion = false; // Track if answered current question
        let questionStartTime = null; // Track when question was shown

        // Update API_URL from input field
        function updateApiUrl() {
            const serverUrlInput = document.getElementById('serverUrl');
            if (serverUrlInput) {
                API_URL = serverUrlInput.value.trim().replace(/\/$/, '') || 'http://localhost:5000';
                SOCKET_URL = API_URL;
            }
        }

        // Test Server Connection
        async function testConnection() {
            updateApiUrl();
            
            if (!API_URL) {
                log('‚ùå Please enter server URL', 'error');
                return;
            }

            try {
                log(`üîç Testing connection to ${API_URL}...`, 'info');
                
                // Try to fetch a simple endpoint or health check
                const response = await fetch(`${API_URL}/health`, {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                }).catch(() => {
                    // If /health doesn't exist, try the API base
                    return fetch(`${API_URL}/api/auth/login`, {
                        method: 'OPTIONS',
                        headers: { 'Accept': 'application/json' }
                    });
                });

                if (response.ok || response.status === 404 || response.status === 405) {
                    log('‚úÖ Server is reachable!', 'success');
                    
                    // Test socket endpoint
                    log('üîç Testing socket endpoint...', 'info');
                    try {
                        const socketTest = await fetch(`${API_URL}/socket.io/?EIO=4&transport=polling`, {
                            method: 'GET'
                        });
                        if (socketTest.status === 200 || socketTest.status === 400) {
                            log('‚úÖ Socket endpoint is accessible!', 'success');
                        } else {
                            log(`‚ö†Ô∏è Socket endpoint returned status: ${socketTest.status}`, 'warning');
                        }
                    } catch (socketError) {
                        log('‚ö†Ô∏è Could not test socket endpoint: ' + socketError.message, 'warning');
                    }
                    
                    showStatus('loginStatus', 'Server is reachable. You can proceed with login.', 'success');
                } else {
                    log(`‚ö†Ô∏è Server responded with status: ${response.status}`, 'warning');
                    showStatus('loginStatus', `Server responded (Status: ${response.status})`, 'info');
                }
            } catch (error) {
                log('‚ùå Cannot reach server: ' + error.message, 'error');
                log('üí° Make sure:', 'warning');
                log('   1. Server is running', 'warning');
                log('   2. Server URL is correct', 'warning');
                log('   3. No trailing slash in URL', 'warning');
                log('   4. CORS is enabled on server', 'warning');
                showStatus('loginStatus', 'Cannot reach server. Check logs for details.', 'error');
            }
        }

        function log(message, type = 'info') {
            const logsContainer = document.getElementById('logs');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            logEntry.textContent = `[${timestamp}] ${message}`;
            logsContainer.appendChild(logEntry);
            logsContainer.scrollTop = logsContainer.scrollHeight;
        }

        function clearLogs() {
            document.getElementById('logs').innerHTML = '';
            log('Logs cleared', 'info');
        }

        function displayApiResponse(response, endpoint = '') {
            const responseDiv = document.getElementById('apiResponseDisplay');
            if (!responseDiv) return;
            try {
                const formatted = JSON.stringify(response, null, 2);
                responseDiv.textContent = endpoint ? `[${endpoint}]\n${formatted}` : formatted;
                responseDiv.classList.remove('empty');
            } catch (error) {
                responseDiv.textContent = `Error: ${error.message}`;
                responseDiv.classList.remove('empty');
            }
        }

        function clearApiResponse() {
            const responseDiv = document.getElementById('apiResponseDisplay');
            if (responseDiv) {
                responseDiv.textContent = 'No API response yet...';
                responseDiv.classList.add('empty');
            }
        }

        function showStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.className = `status ${type}`;
            element.textContent = message;
        }

        // Helper function to safely parse JSON response (handles ngrok HTML responses)
        async function safeJsonParse(response) {
            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.includes('application/json')) {
                const text = await response.text();
                if (text.includes('<!DOCTYPE') || text.includes('<html')) {
                    throw new Error('Received HTML instead of JSON. This might be ngrok interstitial page. Make sure to click through or use ngrok-skip-browser-warning header.');
                }
                throw new Error(`Server returned non-JSON response (Status: ${response.status}). Content-Type: ${contentType}`);
            }
            return await response.json();
        }

        // Helper function to get common headers for API calls
        function getApiHeaders(includeAuth = true) {
            const headers = {
                'Accept': 'application/json'
            };
            // Only add ngrok header if URL contains ngrok
            if (API_URL && API_URL.includes('ngrok')) {
                headers['ngrok-skip-browser-warning'] = 'true';
            }
            if (includeAuth && token) {
                headers['Authorization'] = `Bearer ${token}`;
            }
            return headers;
        }

        // ============================================
        // STEP 1: LOGIN (HTTP API)
        // ============================================
        // Login karo ‚Üí Token milta hai ‚Üí Socket connect hoga
        async function login() {
            updateApiUrl(); // Update API_URL from input field
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;

            try {
                log('üîê Step 1: Attempting login via HTTP API...', 'info');
                log(`üì° Server URL: ${API_URL}`, 'info');
                // HTTP API Call - Database me user verify hota hai
                const response = await fetch(`${API_URL}/api/auth/login`, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        ...getApiHeaders(false)
                    },
                    body: JSON.stringify({ email, password })
                });

                const data = await safeJsonParse(response);
                displayApiResponse(data, 'POST /api/auth/login');
                if (data.status === 1 && data.data && data.data.token) {
                    token = data.data.token;
                    currentUser = data.data;
                    log('‚úÖ Login successful! Token received.', 'success');
                    showStatus('loginStatus', 'Login successful!', 'success');
                    document.getElementById('connectBtn').disabled = false;
                    
                    // Auto-connect socket after login (500ms delay)
                    log('üîå Step 2: Auto-connecting socket...', 'info');
                    setTimeout(() => connectSocket(), 500);
                } else {
                    log('‚ùå Login failed: ' + (data.message || 'Invalid credentials'), 'error');
                    showStatus('loginStatus', data.message || 'Login failed', 'error');
                }
            } catch (error) {
                log('‚ùå Login error: ' + error.message, 'error');
                showStatus('loginStatus', 'Login error: ' + error.message, 'error');
            }
        }

        // ============================================
        // STEP 2: SOCKET CONNECTION (Auto after Login)
        // ============================================
        // Socket connect hota hai JWT token ke saath
        // Ye pehle hota hai, create/join room se pehle
        function connectSocket() {
            if (!token) {
                log('‚ùå Please login first', 'error');
                return;
            }

            if (socket && socket.connected) {
                log('‚ö†Ô∏è Socket already connected', 'warning');
                return;
            }

            log('üîå Connecting to socket...', 'info');
            socket = io(SOCKET_URL, {
                auth: { token: token },
                transports: ['websocket', 'polling']
            });

            socket.on('connect', () => {
                log('‚úÖ Socket connected! ID: ' + socket.id, 'success');
                showStatus('socketStatus', 'Socket connected!', 'success');
                document.getElementById('connectBtn').disabled = true;
                document.getElementById('roomSection').classList.remove('hidden');
            });

            socket.on('connect_error', (error) => {
                log('‚ùå Socket error: ' + error.message, 'error');
                showStatus('socketStatus', 'Connection error', 'error');
            });

            socket.on('disconnect', (reason) => {
                log('üëã Disconnected: ' + reason, 'warning');
                showStatus('socketStatus', 'Disconnected', 'error');
            });

            // Game Events
            socket.on('player:joined', (data) => {
                log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'success');
                log('üë§ üë§ üë§ NEW PLAYER JOINED! üë§ üë§ üë§', 'success');
                log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'success');
                
                // Acknowledge message if taskId present (buffer system)
                if (data.taskId) {
                    socket.emit('message:ack', { taskId: data.taskId }, (response) => {
                        if (response && response.success) {
                            log('‚úÖ Player joined message acknowledged', 'success');
                        }
                    });
                }
                
                // Display all player data
                const player = data.player || {};
                log('üìã PLAYER DETAILS:', 'info');
                log('   Name: ' + (player.username || 'Unknown'), 'success');
                log('   Player ID: ' + (player.userId || player.id || 'Unknown'), 'info');
                log('   Avatar: ' + (player.avatar || 'No avatar'), 'info');
                log('   Score: ' + (player.score || 0), 'info');
                log('   Is Host: ' + (player.isHost ? 'Yes üëë' : 'No'), 'info');
                log('   Ready Status: ' + (player.isReady ? 'Ready ‚úì' : 'Not Ready'), 'info');
                
                log('üìä ROOM STATUS:', 'info');
                log('   Total Players: ' + (data.players?.length || 0), 'info');
                log('   All Players:', 'info');
                (data.players || []).forEach((p, index) => {
                    log(`      ${index + 1}. ${p.username} ${p.isHost ? '(Host üëë)' : ''} ${p.isReady ? '(Ready ‚úì)' : '(Not Ready)'}`, 'info');
                });
                log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
                
                // Show detailed notification in UI
                if (player.username) {
                    const playerInfo = `
                        <div style="padding: 15px; background: #e8f5e9; border-left: 4px solid #4caf50; border-radius: 5px; margin: 10px 0;">
                            <h4 style="margin: 0 0 10px 0; color: #2e7d32;">üéâ New Player Joined!</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9em;">
                                <div><strong>Name:</strong> ${player.username}</div>
                                <div><strong>ID:</strong> ${player.userId || player.id || 'N/A'}</div>
                                <div><strong>Score:</strong> ${player.score || 0}</div>
                                <div><strong>Status:</strong> ${player.isHost ? 'üëë Host' : 'Player'}</div>
                                <div><strong>Ready:</strong> ${player.isReady ? '‚úì Yes' : '‚è≥ No'}</div>
                                <div><strong>Avatar:</strong> ${player.avatar || 'None'}</div>
                            </div>
                            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #c8e6c9;">
                                <strong>Total Players in Room:</strong> ${data.players?.length || 0}
                            </div>
                        </div>
                    `;
                    const statusDiv = document.getElementById('lobbyStatus');
                    if (statusDiv) {
                        statusDiv.innerHTML = playerInfo;
                        statusDiv.className = 'status success';
                        // Auto-hide after 5 seconds
                        setTimeout(() => {
                            statusDiv.innerHTML = '';
                        }, 5000);
                    }
                }
                
                updateLobby();
            });

            socket.on('player:left', (data) => {
                log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'warning');
                log('üëã PLAYER LEFT THE ROOM', 'warning');
                log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'warning');
                log('Player ID: ' + (data.playerId || 'Unknown'), 'warning');
                log('Remaining Players: ' + (data.players?.length || 0), 'info');
                log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
                
                if (data.playerId) {
                    showStatus('lobbyStatus', `üëã A player left the room`, 'warning');
                    setTimeout(() => {
                        const statusDiv = document.getElementById('lobbyStatus');
                        if (statusDiv) statusDiv.textContent = '';
                    }, 3000);
                }
                
                updateLobby();
            });

            socket.on('player:removed', (data) => {
                log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'warning');
                log(`üëã PLAYER REMOVED (${data.reason})`, 'warning');
                log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'warning');
                log('Player ID: ' + (data.playerId || 'Unknown'), 'warning');
                log('Reason: ' + (data.reason || 'Unknown'), 'info');
                log('Remaining Players: ' + (data.players?.length || 0), 'info');
                
                // Check if current user was removed (should not acknowledge if removed)
                const currentUserId = currentUser?.user_id || currentUser?._id;
                if (data.playerId === currentUserId) {
                    log('‚ö†Ô∏è You were removed from the room', 'error');
                    showStatus('lobbyStatus', 'You were removed from the room', 'error');
                    document.getElementById('lobbySection').classList.add('hidden');
                    document.getElementById('roomSection').classList.remove('hidden');
                    currentRoom = null;
                    return; // Don't acknowledge if you were removed
                }
                
                // Acknowledge message if taskId present (buffer system)
                if (data.taskId) {
                    socket.emit('message:ack', { taskId: data.taskId }, (response) => {
                        if (response && response.success) {
                            log('‚úÖ Player removed message acknowledged', 'success');
                        }
                    });
                }
                
                if (data.newHostId) {
                    log('üëë New Host Assigned: ' + data.newHostId, 'success');
                    showStatus('lobbyStatus', `üëë New host assigned!`, 'success');
                } else {
                    showStatus('lobbyStatus', `üëã A player ${data.reason} the room`, 'warning');
                }
                
                setTimeout(() => {
                    const statusDiv = document.getElementById('lobbyStatus');
                    if (statusDiv) statusDiv.textContent = '';
                }, 3000);
                
                updateLobby();
            });

            socket.on('player:ready', (data) => {
                log('‚úÖ Player ready: ' + JSON.stringify(data), 'info');
                updateLobby();
            });

            socket.on('game:started', async (data) => {
                log('üéÆ Game started!', 'success');
                document.getElementById('lobbySection').classList.add('hidden');
                document.getElementById('gameSection').classList.remove('hidden');
                totalQuestions = data.totalQuestions || 0;
                currentQuestionIndex = 0;
                hasAnsweredCurrentQuestion = false;
                
                // Use questions from join response if already stored, otherwise fetch from API
                if (allQuestions && allQuestions.length > 0) {
                    log(`‚úÖ Using ${allQuestions.length} questions already stored from join response (sequence order)`, 'success');
                    log(`üìã First question preview: ${JSON.stringify(allQuestions[0], null, 2)}`, 'info');
                    
                    // Show first question (first in response = first to display)
                    log(`üéØ Showing first question (index 0)...`, 'info');
                    showQuestion(allQuestions[0], 30);
                } else {
                    // Fetch all questions from API
                    try {
                        log('üì• Fetching questions from API...', 'info');
                        const response = await fetch(`${API_URL}/api/game/questions/${currentRoom}`, {
                            headers: getApiHeaders(true)
                        });
                        const questionsData = await safeJsonParse(response);
                        log(`üì• Questions API Response: ${JSON.stringify(questionsData, null, 2)}`, 'info');
                        
                        if (questionsData.status === 1) {
                            // Store questions in the exact order received from response
                            allQuestions = questionsData.data.questions || [];
                            // Ensure questions are in sequence order (no sorting)
                            log(`‚úÖ Loaded ${allQuestions.length} questions in sequence order`, 'success');
                            log(`üìã First question preview: ${JSON.stringify(allQuestions[0], null, 2)}`, 'info');
                            
                            // Show first question (first in response = first to display)
                            if (allQuestions.length > 0) {
                                log(`üéØ Showing first question (index 0)...`, 'info');
                                showQuestion(allQuestions[0], 30);
                            } else {
                                log('‚ùå No questions in array!', 'error');
                                showStatus('gameStatus', 'No questions available', 'error');
                            }
                        } else {
                            log('‚ùå Failed to load questions: ' + questionsData.message, 'error');
                            showStatus('gameStatus', 'Failed to load questions: ' + questionsData.message, 'error');
                        }
                    } catch (error) {
                        log('‚ùå Error fetching questions: ' + error.message, 'error');
                    }
                }
            });

            socket.on('question:answered', (data) => {
                log('‚úÖ Answer submitted by player: ' + data.playerId, 'info');
                // Handle ACK if taskId present
                if (data.taskId) {
                    socket.emit('message:ack', { taskId: data.taskId }, (response) => {
                        if (response && response.success) {
                            log('‚úÖ Message acknowledged', 'success');
                        }
                    });
                }
            });

            socket.on('all:answered', async (data) => {
                log('üéØ All players answered question: ' + data.questionId, 'success');
                
                // If leaderboard data is already in the event, use it directly
                if (data.leaderboard && Array.isArray(data.leaderboard)) {
                    log('üìä Leaderboard received in all:answered event', 'success');
                    showQuestionLeaderboard({
                        questionId: data.questionId,
                        leaderboard: data.leaderboard,
                        correctAnswer: data.correctAnswer,
                        totalPlayers: data.totalPlayers,
                        answeredPlayers: data.answeredPlayers
                    });
                } else {
                    // Fallback: Request leaderboard for this question (existing flow)
                    socket.emit('question:leaderboard', { questionId: data.questionId }, (response) => {
                        if (response && response.success) {
                            log('üìä Leaderboard received via request', 'success');
                            showQuestionLeaderboard(response.data);
                        }
                    });
                }
            });

            socket.on('question:leaderboard', (data) => {
                log('üìä Question leaderboard received', 'success');
                // Handle ACK if taskId present
                if (data.taskId) {
                    socket.emit('message:ack', { taskId: data.taskId }, (response) => {
                        if (response && response.success) {
                            log('‚úÖ Leaderboard message acknowledged', 'success');
                        }
                    });
                }
                showQuestionLeaderboard(data);
                
                // After showing leaderboard, wait 3 seconds then show next question
                setTimeout(() => {
                    moveToNextQuestion();
                }, 3000);
            });

            socket.on('game:ended', (data) => {
                log('üèÅ Game ended!', 'success');
                if (timerInterval) clearInterval(timerInterval);
                document.getElementById('gameSection').classList.add('hidden');
                document.getElementById('summarySection').classList.remove('hidden');
                getSummary();
            });
        }

        // ============================================
        // STEP 3: CREATE ROOM (HTTP API + Socket)
        // ============================================
        // 1. HTTP API: Database me room create hota hai
        // 2. Socket Emit: Real-time updates ke liye socket room join
        async function createRoom() {
            // Check: Socket pehle se connected hona chahiye
            if (!socket || !socket.connected) {
                log('‚ùå Socket not connected. Please connect socket first!', 'error');
                showStatus('createRoomStatus', 'Socket not connected. Connect socket first!', 'error');
                return;
            }

            const gameId = document.getElementById('gameId')?.value || 'trivia_rush';
            const numberOfQuestions = parseInt(document.getElementById('numberOfQuestions').value) || 5;
            const maximumPlayers = parseInt(document.getElementById('maximumPlayers').value) || 7;
            const roomCode = 'ROOM' + Date.now();

            document.getElementById('roomCode').value = roomCode;
            isHost = true;

            // Collect all categories
            const categories = {
                quran: {
                    enabled: document.getElementById('catQuran')?.checked || false,
                    difficulty: document.getElementById('diffQuran')?.value || 'medium'
                },
                hadith: {
                    enabled: document.getElementById('catHadith')?.checked || false,
                    difficulty: document.getElementById('diffHadith')?.value || 'medium'
                },
                history: {
                    enabled: document.getElementById('catHistory')?.checked || false,
                    difficulty: document.getElementById('diffHistory')?.value || 'medium'
                },
                fiqh: {
                    enabled: document.getElementById('catFiqh')?.checked || false,
                    difficulty: document.getElementById('diffFiqh')?.value || 'medium'
                },
                seerah: {
                    enabled: document.getElementById('catSeerah')?.checked || false,
                    difficulty: document.getElementById('diffSeerah')?.value || 'medium'
                }
            };

            // Check if at least one category is enabled
            const enabledCategories = Object.values(categories).filter(cat => cat.enabled);
            if (enabledCategories.length === 0) {
                log('‚ùå At least one category must be enabled. Enabling Quran by default.', 'warning');
                categories.quran.enabled = true;
            }

            // Debug: Log categories being sent
            log('üìã Categories: ' + JSON.stringify(categories), 'info');

            try {
                // ============================================
                // PART 1: HTTP API CALL (Database Update)
                // ============================================
                // Room database me create hota hai
                // Transaction safety, data consistency
                log('üéÆ Step 3a: Creating room via HTTP API (Database)...', 'info');
                const response = await fetch(`${API_URL}/api/game/create`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...getApiHeaders(true)
                    },
                    body: JSON.stringify({
                        gameId: gameId,
                        categories,
                        numberOfQuestions,
                        maximumPlayers
                    })
                });

                const data = await safeJsonParse(response);
                if (data.status === 1) {
                    currentRoom = data.data.roomCode;
                    isHost = true; // Set isHost to true when creating room
                    log('‚úÖ Step 3a: Room created in database: ' + currentRoom, 'success');
                    log('üëë Host status set: ' + isHost, 'success');
                    showStatus('createRoomStatus', 'Room created: ' + currentRoom, 'success');
                    
                    // Socket join is now handled by joinGame API automatically
                    log('‚úÖ Socket room join handled by API automatically', 'success');
                    document.getElementById('lobbySection').classList.remove('hidden');
                    
                    // Update lobby immediately and then again after delay to ensure button state is correct
                    updateLobby();
                    setTimeout(() => {
                        updateLobby();
                    }, 1000);
                } else {
                    log('‚ùå Failed to create room: ' + data.message, 'error');
                    showStatus('createRoomStatus', data.message, 'error');
                }
            } catch (error) {
                log('‚ùå Create room error: ' + error.message, 'error');
            }
        }

        // ============================================
        // STEP 4: JOIN ROOM (HTTP API + Socket)
        // ============================================
        // 1. HTTP API: Database me player add hota hai
        // 2. Socket Emit: Real-time updates ke liye socket room join
        async function joinRoom() {
            // Check: Socket pehle se connected hona chahiye
            if (!socket || !socket.connected) {
                log('‚ùå Socket not connected. Please connect socket first!', 'error');
                showStatus('joinRoomStatus', 'Socket not connected. Connect socket first!', 'error');
                return;
            }

            const roomCode = document.getElementById('joinRoomCode').value.trim().toUpperCase();
            if (!roomCode) {
                showStatus('joinRoomStatus', 'Please enter room code', 'error');
                return;
            }

            try {
                // ============================================
                // PART 1: HTTP API CALL (Database Update)
                // ============================================
                // Player database me room me add hota hai
                log('üö™ Step 4a: Joining room via HTTP API (Database)...', 'info');
                const response = await fetch(`${API_URL}/api/game/join`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...getApiHeaders(true)
                    },
                    body: JSON.stringify({
                        roomCode: roomCode,
                        username: currentUser.email?.split('@')[0] || 'Player1',
                        avatar: ''
                    })
                });

                const data = await safeJsonParse(response);
                displayApiResponse(data, 'POST /api/game/join');
                if (data.status === 1) {
                    currentRoom = roomCode;
                    isHost = false;
                    log('‚úÖ Step 4a: Joined room in database: ' + currentRoom, 'success');
                    log('üìä Room Details:', 'info');
                    log('   - Room Code: ' + currentRoom, 'info');
                    log('   - Total Players: ' + (data.data.players?.length || 0), 'info');
                    log('   - Room Status: ' + (data.data.status || 'waiting'), 'info');
                    log('   - Max Players: ' + (data.data.settings?.maximumPlayers || 'N/A'), 'info');
                    
                    // Store questions from join response in exact sequence order
                    if (data.data.questions && Array.isArray(data.data.questions)) {
                        allQuestions = data.data.questions || [];
                        log(`‚úÖ Stored ${allQuestions.length} questions from join response in sequence order`, 'success');
                        log(`üìã Questions sequence: ${allQuestions.map((q, idx) => `Q${idx + 1}`).join(', ')}`, 'info');
                    }
                    
                    showStatus('joinRoomStatus', '‚úÖ Joined room: ' + currentRoom, 'success');
                    
                    // Show lobby section
                    document.getElementById('lobbySection').classList.remove('hidden');
                    updateLobby();
                    
                    // Socket join is now handled by joinGame API automatically
                    log('‚úÖ Socket room join handled by API automatically', 'success');
                    log('üéâ You will now receive events when other players join/leave!', 'success');
                    log('üì° Listening for: player:joined, player:left, player:ready, game:started', 'info');
                } else {
                    log('‚ùå Failed to join room: ' + data.message, 'error');
                    showStatus('joinRoomStatus', data.message, 'error');
                }
            } catch (error) {
                log('‚ùå Join room error: ' + error.message, 'error');
            }
        }

        // Update Lobby
        async function updateLobby() {
            if (!currentRoom) return;

            try {
                const response = await fetch(`${API_URL}/api/game/lobby/${currentRoom}`, {
                    headers: getApiHeaders(true)
                });
                
                const data = await safeJsonParse(response);
                
                if (data.status === 1) {
                    const lobby = data.data;
                    document.getElementById('roomInfo').innerHTML = `
                        <p><strong>Room Code:</strong> ${lobby.roomCode}</p>
                        <p><strong>Status:</strong> ${lobby.status}</p>
                        <p><strong>Players:</strong> ${lobby.players?.length || 0} / ${lobby.settings?.maximumPlayers || 0}</p>
                    `;

                    let playersHtml = '<h4 style="margin-bottom: 10px; color: #333;">Players in Room:</h4>';
                    const currentUserId = currentUser?.user_id || currentUser?._id;
                    
                    // Check if current user is host - use both isHost variable and lobby data
                    const currentId = currentUserId?.toString();
                    
                    // First check from lobby data (most reliable)
                    const isHostFromLobby = (lobby.players || []).some(p => {
                        const pid = (p.id || p.userId?._id || p.userId)?.toString();
                        if (!pid || !currentId) return false;
                        return pid === currentId && p.isHost;
                    });
                    
                    // Use lobby data if available, otherwise use isHost variable
                    const isCurrentUserHost = isHostFromLobby || isHost;
                    
                    // Update isHost variable if we found it from lobby
                    if (isHostFromLobby && !isHost) {
                        isHost = true;
                        log('üëë Host status updated from lobby data', 'success');
                    }
                    
                    // Debug log for host check
                    log('üîç [DEBUG] Host Check:', 'info');
                    log(`   - isHost variable: ${isHost}`, 'info');
                    log(`   - currentUserId: ${currentUserId}`, 'info');
                    log(`   - isCurrentUserHost: ${isCurrentUserHost}`, 'info');
                    log(`   - Players: ${JSON.stringify((lobby.players || []).map(p => ({
                        userId: p.userId?._id || p.userId,
                        username: p.username,
                        isHost: p.isHost
                    })), null, 2)}`, 'info');
                    
                    (lobby.players || []).forEach((p, i) => {
                        // Extract player ID - handle multiple formats (lobby API returns 'id' field)
                        let pid = null;
                        if (p.id) {
                            pid = p.id;
                        } else if (p.userId) {
                            pid = p.userId._id || p.userId.id || p.userId;
                        } else if (p._id) {
                            pid = p._id;
                        }
                        const playerId = pid ? pid.toString() : null;
                        
                        // Extract current user ID for comparison
                        const currentId = currentUserId?.toString();
                        
                        const isMe = (() => {
                            if (!playerId || !currentId) return false;
                            return playerId === currentId;
                        })();
                        const showKickButton = isCurrentUserHost && !isMe && !p.isHost && playerId;
                        
                        // Debug log
                        if (showKickButton) {
                            console.log('üîç [KICK BUTTON] Player:', {
                                playerId: playerId,
                                username: p.username,
                                isHost: p.isHost,
                                showKickButton: showKickButton
                            });
                        }
                        
                        playersHtml += `
                            <div class="player-item" style="padding: 10px; margin: 5px 0; background: ${isMe ? '#e3f2fd' : 'white'}; border-radius: 5px; border-left: 3px solid ${isMe ? '#2196f3' : '#ddd'};">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <span style="font-weight: ${isMe ? 'bold' : 'normal'}; color: ${isMe ? '#1976d2' : '#333'};">
                                            ${i + 1}. ${p.username} ${isMe ? '(You)' : ''}
                                        </span>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <span class="badge ${p.isHost ? 'host' : ''} ${p.isReady ? 'ready' : ''}">
                                            ${p.isHost ? 'üëë Host' : ''} ${p.isReady ? '‚úì Ready' : '‚è≥ Not Ready'}
                                        </span>
                                        ${showKickButton ? `<button onclick="kickPlayer('${playerId}')" style="background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 12px;">Kick</button>` : ''}
                                    </div>
                                </div>
                                ${p.score !== undefined ? `<div style="font-size: 0.85em; color: #666; margin-top: 5px;">Score: ${p.score}</div>` : ''}
                            </div>
                        `;
                    });
                    document.getElementById('playersList').innerHTML = playersHtml;

                    // Enable start button (no ready check needed, minimum 2 players)
                    const minPlayers = (lobby.players || []).length >= 2;
                    const startBtn = document.getElementById('startBtn');
                    
                    // Debug logging
                    log(`üîç Start Button Debug:`, 'info');
                    log(`   - Room Status: ${lobby.status}`, 'info');
                    log(`   - isHost variable: ${isHost}`, 'info');
                    log(`   - isCurrentUserHost: ${isCurrentUserHost}`, 'info');
                    log(`   - Min Players (>=2): ${minPlayers} (Total: ${(lobby.players || []).length})`, 'info');
                    log(`   - Current User ID: ${currentUserId}`, 'info');
                    
                    const statusCheck = lobby.status === 'waiting';
                    const hostCheck = isCurrentUserHost;
                    const playersCheck = minPlayers;
                    
                    const shouldDisable = !statusCheck || !hostCheck || !playersCheck;
                    log(`   - Should Disable: ${shouldDisable}`, 'info');
                    log(`   - Reasons: status!='waiting': ${!statusCheck}, !isHost: ${!hostCheck}, !minPlayers: ${!playersCheck}`, 'info');
                    
                    if (startBtn) {
                        // Always show button if user is host, but disable based on conditions
                        if (isCurrentUserHost) {
                            startBtn.style.display = 'block';
                            startBtn.disabled = shouldDisable;
                            log(`‚úÖ Start button ${shouldDisable ? 'DISABLED' : 'ENABLED'} and visible for host`, shouldDisable ? 'warning' : 'success');
                            if (shouldDisable) {
                                const reasons = [];
                                if (!statusCheck) reasons.push('Room status is not waiting');
                                if (!hostCheck) reasons.push('User is not host');
                                if (!playersCheck) reasons.push('Less than 2 players');
                                log(`   ‚ö†Ô∏è Button disabled because: ${reasons.join(', ')}`, 'warning');
                            }
                        } else {
                            startBtn.style.display = 'none';
                            log(`‚ö†Ô∏è Start button hidden (not host)`, 'warning');
                        }
                    }
                }
            } catch (error) {
                log('‚ùå Error updating lobby: ' + error.message, 'error');
            }
        }

        // Toggle Ready - REMOVED (No longer needed, ready check removed)

        // Start Game (Socket Event)
        function startGame() {
            if (!socket || !socket.connected) {
                log('‚ùå Socket not connected', 'error');
                return;
            }
            if (!currentRoom) {
                log('‚ùå Not in any room', 'error');
                return;
            }

            log('üéÆ Starting game via socket...', 'info');
            socket.emit('game:start', {}, (response) => {
                if (response && response.success) {
                    log('‚úÖ Game start request sent', 'success');
                } else {
                    log('‚ùå Failed to start: ' + (response?.error || 'Unknown error'), 'error');
                }
            });
        }

        // Leave Room
        function leaveRoom() {
            if (!socket || !socket.connected) {
                log('‚ùå Socket not connected', 'error');
                return;
            }
            if (!currentRoom) {
                log('‚ùå Not in any room', 'error');
                return;
            }

            log('üëã Leaving room...', 'info');
            socket.emit('room:leave', { roomCode: currentRoom }, (response) => {
                if (response && response.success) {
                    log('‚úÖ Successfully left the room', 'success');
                    showStatus('lobbyStatus', 'Left the room', 'info');
                    currentRoom = null;
                    isHost = false;
                    document.getElementById('lobbySection').classList.add('hidden');
                    document.getElementById('roomSection').classList.remove('hidden');
                } else {
                    log('‚ùå Failed to leave: ' + (response?.error || 'Unknown error'), 'error');
                    showStatus('lobbyStatus', response?.error || 'Failed to leave', 'error');
                }
            });
        }

        // Kick Player (Host Only)
        function kickPlayer(playerId) {
            if (!socket || !socket.connected) {
                log('‚ùå Socket not connected', 'error');
                return;
            }
            if (!currentRoom) {
                log('‚ùå Not in any room', 'error');
                return;
            }

            if (!confirm(`Are you sure you want to kick this player?`)) {
                return;
            }

            log('üë¢ Kicking player: ' + playerId, 'info');
            socket.emit('room:kick', { roomCode: currentRoom, playerId }, (response) => {
                if (response && response.success) {
                    log('‚úÖ Player kicked successfully', 'success');
                    showStatus('lobbyStatus', 'Player kicked', 'success');
                    updateLobby();
                } else {
                    log('‚ùå Failed to kick: ' + (response?.error || 'Unknown error'), 'error');
                    showStatus('lobbyStatus', response?.error || 'Failed to kick', 'error');
                }
            });
        }

        // Show Question
        function showQuestion(question, questionTimeLimit) {
            if (!question) return;

            currentQuestion = question;
            timeLimit = questionTimeLimit || 30; // Store globally
            timeLeft = timeLimit;
            hasAnsweredCurrentQuestion = false;
            questionStartTime = Date.now();
            
            document.getElementById('timer').textContent = timeLeft;
            document.getElementById('timer').classList.remove('warning', 'danger');

            const container = document.getElementById('questionContainer');
            if (!container) {
                log('‚ùå Question container not found!', 'error');
                return;
            }
            
            const questionNum = currentQuestionIndex + 1;
            const totalQ = totalQuestions || allQuestions.length || '?';
            const questionText = question.question || question.questionText || 'No question available';
            const questionOptions = question.options || [];
            
            log(`üìù Showing question ${questionNum}: ${questionText}`, 'info');
            log(`üìù Options count: ${questionOptions.length}`, 'info');
            log(`üìù Full question object: ${JSON.stringify(question, null, 2)}`, 'info');
            
            container.innerHTML = `
                <h3>Question ${questionNum}${totalQ !== '?' ? ' of ' + totalQ : ''}</h3>
                <div class="question-text">${questionText}</div>
                <div id="optionsContainer" style="margin-top: 25px;"></div>
                <div id="leaderboardContainer" style="margin-top: 20px; display: none;"></div>
            `;

            const optionsContainer = document.getElementById('optionsContainer');
            if (!optionsContainer) {
                log('‚ùå Options container not found!', 'error');
                return;
            }
            
            if (questionOptions.length === 0) {
                optionsContainer.innerHTML = '<p style="color: red; padding: 20px;">‚ö†Ô∏è No options available for this question</p>';
                log('‚ö†Ô∏è No options found for question', 'warning');
                return;
            }
            
            questionOptions.forEach((option, index) => {
                if (!option) {
                    log(`‚ö†Ô∏è Option ${index} is empty/null`, 'warning');
                    return;
                }
                const btn = document.createElement('button');
                btn.className = 'option-btn';
                btn.textContent = `${String.fromCharCode(65 + index)}. ${option}`;
                btn.onclick = () => submitAnswer(index);
                optionsContainer.appendChild(btn);
            });
            
            log(`‚úÖ Question displayed with ${questionOptions.length} options`, 'success');

            // Start timer with visual feedback
            const timerElement = document.getElementById('timer');
            if (timerInterval) clearInterval(timerInterval);
            
            timerInterval = setInterval(() => {
                timeLeft--;
                timerElement.textContent = timeLeft;
                
                // Change color based on time left
                timerElement.classList.remove('warning', 'danger');
                if (timeLeft <= 5) {
                    timerElement.classList.add('danger');
                } else if (timeLeft <= 10) {
                    timerElement.classList.add('warning');
                }
                
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    timerElement.textContent = 'Time Up!';
                    timerElement.classList.add('danger');
                    handleTimeout();
                }
            }, 1000);
        }

        // Show Question Leaderboard
        function showQuestionLeaderboard(data) {
            const leaderboardContainer = document.getElementById('leaderboardContainer');
            if (!leaderboardContainer) return;

            let html = '<h4 style="margin-top: 20px; color: #4caf50;">üìä Question Leaderboard</h4>';
            html += `<p style="color: #666; margin: 10px 0;">Correct Answer: Option ${String.fromCharCode(65 + data.correctAnswer)}</p>`;
            html += '<div style="background: white; padding: 15px; border-radius: 8px; margin-top: 10px;">';
            
            data.leaderboard.forEach((player, index) => {
                const statusIcon = player.hasAnswered 
                    ? (player.isCorrect ? '‚úÖ' : '‚ùå') 
                    : '‚è±Ô∏è';
                const rankBadge = player.rank_badge > 0 
                    ? `<span style="background: #4caf50; color: white; padding: 2px 8px; border-radius: 12px; font-weight: bold; margin-right: 8px;">${player.rank_badge}</span>`
                    : `<span style="background: #f44336; color: white; padding: 2px 8px; border-radius: 12px; font-weight: bold; margin-right: 8px;">-1</span>`;
                html += `
                    <div style="padding: 10px; margin: 5px 0; background: ${player.isCorrect ? '#e8f5e9' : '#ffebee'}; border-radius: 5px; display: flex; justify-content: space-between; align-items: center;">
                        <span>${rankBadge} ${player.username} ${statusIcon}</span>
                        <span>Score: ${player.score} | Time: ${player.timeTaken}s</span>
                    </div>
                `;
            });
            html += '</div>';
            
            leaderboardContainer.innerHTML = html;
            leaderboardContainer.style.display = 'block';
        }

        // Handle Timeout
        function handleTimeout() {
            if (hasAnsweredCurrentQuestion) {
                log('‚ö†Ô∏è Timeout but already answered', 'warning');
                return;
            }
            
            log('‚è±Ô∏è Time expired - submitting timeout', 'warning');
            const timeTaken = timeLimit; // Full time limit
            submitAnswer(null, timeTaken, true);
        }

        // Submit Answer (Socket Event)
        function submitAnswer(selectedOption, timeTakenOverride = null, isTimeout = false) {
            if (!socket || !socket.connected) {
                log('‚ùå Socket not connected', 'error');
                return;
            }
            if (!currentQuestion || !currentRoom) return;
            if (hasAnsweredCurrentQuestion && !isTimeout) {
                log('‚ö†Ô∏è Already answered this question', 'warning');
                return;
            }

            // Disable buttons
            document.querySelectorAll('.option-btn').forEach(btn => btn.disabled = true);
            if (timerInterval) clearInterval(timerInterval);

            const questionId = currentQuestion._id || currentQuestion.id;
            const timeTaken = timeTakenOverride !== null 
                ? timeTakenOverride 
                : (questionStartTime ? Math.floor((Date.now() - questionStartTime) / 1000) : timeLimit - timeLeft);

            log(`üìù Submitting answer via socket: ${selectedOption !== null ? selectedOption : 'TIMEOUT'} (Time: ${timeTaken}s)`, 'info');
            
            hasAnsweredCurrentQuestion = true;

            socket.emit('answer:submit', {
                questionId: questionId,
                answer: selectedOption,
                timeTaken: timeTaken
            }, (response) => {
                if (response && response.success) {
                    log('‚úÖ Answer submitted successfully', 'success');
                    showStatus('gameStatus', 'Answer submitted! Waiting for others...', 'success');
                } else {
                    log('‚ùå Failed to submit: ' + (response?.error || 'Unknown error'), 'error');
                    showStatus('gameStatus', 'Failed to submit answer', 'error');
                    hasAnsweredCurrentQuestion = false; // Allow retry
                }
            });
        }

        // Move to Next Question
        function moveToNextQuestion() {
            currentQuestionIndex++;
            hasAnsweredCurrentQuestion = false;
            
            if (currentQuestionIndex >= allQuestions.length) {
                log('üèÅ All questions completed!', 'success');
                
                // Clear timer
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
                
                // Hide game section, show summary section
                const gameSection = document.getElementById('gameSection');
                const summarySection = document.getElementById('summarySection');
                if (gameSection) gameSection.classList.add('hidden');
                if (summarySection) summarySection.classList.remove('hidden');
                
                // Hide question leaderboard container
                const leaderboardContainer = document.getElementById('leaderboardContainer');
                if (leaderboardContainer) {
                    leaderboardContainer.style.display = 'none';
                }
                
                // Load final summary and leaderboard
                log('üìä Loading final summary and leaderboard...', 'info');
                getSummary();
                setTimeout(() => {
                    log('üìä Calling getLeaderboard() after 500ms delay...', 'info');
                    getLeaderboard();
                }, 500);
                
                return;
            }
            
            // Show next question
            if (allQuestions[currentQuestionIndex]) {
                showQuestion(allQuestions[currentQuestionIndex], 30);
                showStatus('gameStatus', '', 'info');
                const leaderboardContainer = document.getElementById('leaderboardContainer');
                if (leaderboardContainer) {
                    leaderboardContainer.style.display = 'none';
                }
            }
        }

        // Get Summary
        async function getSummary() {
            if (!currentRoom) return;

            try {
                const response = await fetch(`${API_URL}/api/game/summary/${currentRoom}`, {
                    headers: getApiHeaders(true)
                });
                const data = await safeJsonParse(response);
                if (data.status === 1) {
                    const summary = data.data;
                    document.getElementById('summaryContent').innerHTML = `
                        <h3>Your Results</h3>
                        <p><strong>Total Score:</strong> ${summary.totalScore}</p>
                        <p><strong>Correct Answers:</strong> ${summary.correctAnswers}</p>
                        <p><strong>Wrong Answers:</strong> ${summary.wrongAnswers || 0}</p>
                        <p><strong>Skipped Answers:</strong> ${summary.skippedAnswers || 0}</p>
                        <p><strong>Accuracy:</strong> ${summary.accuracy}%</p>
                        <p><strong>Rank:</strong> ${summary.rank}</p>
                    `;
                }
            } catch (error) {
                log('‚ùå Error getting summary: ' + error.message, 'error');
            }
        }

        // Get Leaderboard
        async function getLeaderboard() {
            log('üìä getLeaderboard() called', 'info');
            log('üìä currentRoom: ' + currentRoom, 'info');
            
            if (!currentRoom) {
                log('‚ùå No room code for leaderboard', 'error');
                return;
            }

            try {
                log('üìä Fetching leaderboard from API...', 'info');
                const response = await fetch(`${API_URL}/api/game/leaderboard/${currentRoom}`, {
                    headers: getApiHeaders(true)
                });
                
                log('üìä API Response status: ' + response.status, 'info');
                const data = await safeJsonParse(response);
                if (data.status === 1) {
                    const leaderboard = data.data?.leaderboard?.players || data.data?.leaderboard || [];
                    let html = '<h3>üèÜ Final Leaderboard</h3><ol style="list-style: none; padding: 0;">';
                    leaderboard.forEach((player, index) => {
                        const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                        html += `<li style="padding: 10px; margin: 5px 0; background: ${index < 3 ? '#f0f0f0' : '#fff'}; border-radius: 5px;">
                            <strong>${medal}</strong> ${player.username || 'Unknown'} 
                            - <strong>Score:</strong> ${player.points || player.score || 0} 
                            - <strong>Correct:</strong> ${player.correctAnswers || 0} 
                            - <strong>Accuracy:</strong> ${player.accuracy || 0}%
                        </li>`;
                    });
                    html += '</ol>';
                    document.getElementById('leaderboardContent').innerHTML = html;
                    log('‚úÖ Leaderboard loaded successfully', 'success');
                } else {
                    log('‚ö†Ô∏è ' + (data.message || 'Failed to load leaderboard'), 'warning');
                }
            } catch (error) {
                log('‚ùå Error getting leaderboard: ' + error.message, 'error');
            }
        }

        // API Testing Functions
        async function testGetLobby() {
            if (!currentRoom) { log('‚ùå No room code', 'error'); return; }
            try {
                const response = await fetch(`${API_URL}/api/game/lobby/${currentRoom}`, {
                    headers: getApiHeaders(true)
                });
                const data = await safeJsonParse(response);
                document.getElementById('apiResponse').textContent = JSON.stringify(data, null, 2);
            } catch (error) {
                document.getElementById('apiResponse').textContent = 'Error: ' + error.message;
            }
        }

        async function testGetQuestions() {
            if (!currentRoom) { log('‚ùå No room code', 'error'); return; }
            try {
                const response = await fetch(`${API_URL}/api/game/questions/${currentRoom}`, {
                    headers: getApiHeaders(true)
                });
                const data = await safeJsonParse(response);
                document.getElementById('apiResponse').textContent = JSON.stringify(data, null, 2);
            } catch (error) {
                document.getElementById('apiResponse').textContent = 'Error: ' + error.message;
            }
        }

        async function testGetSummary() {
            if (!currentRoom) { log('‚ùå No room code', 'error'); return; }
            try {
                const response = await fetch(`${API_URL}/api/game/summary/${currentRoom}`, {
                    headers: getApiHeaders(true)
                });
                const data = await safeJsonParse(response);
                document.getElementById('apiResponse').textContent = JSON.stringify(data, null, 2);
            } catch (error) {
                document.getElementById('apiResponse').textContent = 'Error: ' + error.message;
            }
        }

        async function testGetLeaderboard() {
            if (!currentRoom) { log('‚ùå No room code', 'error'); return; }
            try {
                const response = await fetch(`${API_URL}/api/game/leaderboard/${currentRoom}`, {
                    headers: getApiHeaders(true)
                });
                const data = await safeJsonParse(response);
                document.getElementById('apiResponse').textContent = JSON.stringify(data, null, 2);
            } catch (error) {
                document.getElementById('apiResponse').textContent = 'Error: ' + error.message;
            }
        }

        async function testGetMyGames() {
            try {
                const response = await fetch(`${API_URL}/api/game/my-games`, {
                    headers: getApiHeaders(true)
                });
                const data = await safeJsonParse(response);
                document.getElementById('apiResponse').textContent = JSON.stringify(data, null, 2);
            } catch (error) {
                document.getElementById('apiResponse').textContent = 'Error: ' + error.message;
            }
        }

        async function testGetRoom() {
            if (!currentRoom) { log('‚ùå No room code', 'error'); return; }
            try {
                const response = await fetch(`${API_URL}/api/game/room/${currentRoom}`, {
                    headers: getApiHeaders(true)
                });
                const data = await safeJsonParse(response);
                document.getElementById('apiResponse').textContent = JSON.stringify(data, null, 2);
            } catch (error) {
                document.getElementById('apiResponse').textContent = 'Error: ' + error.message;
            }
        }

        // Auto-generate room code
        document.getElementById('roomCode').addEventListener('focus', function() {
            if (!this.value) {
                this.value = 'ROOM' + Date.now();
            }
        });

        log('üöÄ Player 1 (Host) Page Loaded', 'success');
    </script>
</body>
</html>

